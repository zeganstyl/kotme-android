## Наследование, абстрактные классы и методы, интерфейсы

### Наследование
Наследование позволяет общую функциональность нескольких классов выносить в один общий суперкласс, а также совместно обрабатывать объекты, созданные от разных, но родственных, классов. 
В наследовании выделяется два ключевых компонента: 
- Родительский класс (суперкласс), который определяет базовую функциональность.
- Подкласс (класс-наследник), который наследует функциональность базового класса и может расширять или модифицировать ее. 

Чтобы сделать класс наследуемым, необходимо указать ключевое слово `open` при создании класса.
```kotlin
open class Person 
```
Для определения подкласса после его имени ставится двоеточие, затем идет название класса-родителя. 
```kotlin
open class Person(val name: String)
class Student(name: String) : Person(name)
```
Класс Person представляет человека, а класс Student - студента. Класс Person через первичный конструктор устанавливает свойство name. Каждый студент является человеком, поэтому чтобы не дублировать в классе Student функциональность класса Person просто наследуем ее.
То есть в данном случае класс Person является классом-родителем или суперклассом, а класс Student - подклассом или классом-наследником.

При наследовании необходимо инициализировать родительский класс. Если подкласс имеет первичный конструктор, то вместе с ним должен вызываться конструктор родительского класса.
```kotlin
open class Person(val name: String)
class Student(val group: String, name: String) : Person(name)
```
Если же подкласс не имеет никаких конструкторов, то также после двоеточия идет вызов конструктора родительского класса.

Если у класса-наследника нет основного конструктора, тогда каждый последующий дополнительный конструктор должен включать в себя инициализацию родительского класса с помощью ключевого слова `super`:
```kotlin
open class Person(val name: String)
class Student: Person{
    var group: String="undefined"
    constructor(name: String, gr:String) : super(name){
        group = gr
    }
}
```

Стоит также отметить, что для всех классов в языке Kotlin родительским суперклассом является класс **Any**. Он также является родительским классом для любого класса, в котором не указан какой-либо другой родительский класс.
У **Any** есть три метода: `equals()`, `hashCode()` и `toString()`. Эти методы определены для всех классов в Kotlin.

### Абстрактные классы и методы
Абстрактные классы - это классы, которые определяются  с помощью ключевого слова `abstract`. 
Отличительной особенностью абстрактных классов является то, что создать экземпляр такого класса нельзя, то есть абстрактный класс, как и обычный, может иметь свойства, функции, конструкторы, но создать его объект напрямую мы не можем. 
Например, создадим абстрактный класс Person:
```kotlin
abstract class Person(val name: String)
```
Абстрактный класс также может содержать и неабстрактные свойства и функции. Если класс содержит какие-либо свойства и функции, помеченные как абстрактные, весь класс должен быть абстрактным.

Абстрактный класс можно только унаследовать:
```kotlin
abstract class Person(val name: String){
    fun greeting(){
        println("Hello! My name is $name")
    }
}
class Human(name: String): Person(name)
```
Абстрактные классы или методы всегда открыты, поэтому использование ключевого слова `open` необязательно.

Абстрактные классы могут иметь абстрактные методы, которые определяются с ключевым словом `abstract`. У таких функций нет тела. Абстрактные методы можно определить только в абстрактных классах:
```kotlin
abstract class Person(val name: String){
    abstract fun greeting()
}
class Human(name: String): Person(name){
     override fun greeting(){
        println("Hello! My name is $name")
    }
}
```
Если класс наследуется от абстрактного класса, то он должен реализовать все его абстрактные методы. В данном примере, класс Human должен обязательно реализовать функцию greeting. При переопределении методов, применяется модификатор `override`.

### Интерфейсы
Интерфейс представляет собой контракт, который должен реализовать класс. Интерфейсы могут содержать объявления свойств и функций, а также их реализацию по умолчанию.
От интерфейсов, также как от абстрактных классов, нельзя создавать объекты, интерфейсы также как и абстрактные классы предназначены только для их наследования другими классами.

Для определения интерфейса используется ключевое слово `interface`:
```kotlin
interface MyInterface{
    fun foo()      // определение функции без реализации
    fun bar(){     // определение функции с реализацией по умолчанию
        println("A")
    }
}
```
Мы не можем напрямую создать объект интерфейса, так как интерфейс не поддерживает конструкторы и просто представляет контракт, которому класс, реализующиий этот интерфейс, должен соответствовать.
Для применения интерфейса после имени класса ставится двоеточие, за которым следует название интерфейса. 
```kotlin
class Child : MyInterface {
    override fun foo() {
        // тело
    }
}
}
```
При применении интерфейса класс должен реализовать все его абстрактные методы и свойства, а также может предоставить свою реализацию для тех свойств и методов, которые уже имеют реализацию по умолчанию.
При реализации функций необходимо указывать модификатор `override`.

Можно добавлять в интерфейс абстрактные свойства без указания `abstract`, а также свойства с реализацией методов доступа. Свойствам нельзя присвоить значение и инициализировать.
```kotlin
interface MyInterface{
    val num: Int // абстрактное свойство
    val str: String  // свойство с реализацией метода доступа
        get() = "Строка"
    fun bar(){     
        println(str)
    }
}
class Child : MyInterface {
    override val num: Int = 11
}
```
